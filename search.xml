<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pytest执行参数(四)</title>
    <url>/2020/06/22/Pytest%E6%89%A7%E8%A1%8C%E7%94%A8%E4%BE%8B%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1 id="pytest执行参数"><a href="#pytest执行参数" class="headerlink" title="pytest执行参数"></a>pytest执行参数</h1><p>一、执行方式</p>
<p>cmd执行pytest用例有三种方法,以下三种方法都可以，一般推荐第一个</p>
<ul>
<li><strong>pytest</strong></li>
<li><strong>py.test</strong></li>
<li><strong>python -m pytest</strong></li>
</ul>
<p>默认执行文件夹下所有符合条件的用例</p>
<h4 id="2-执行规则和参数"><a href="#2-执行规则和参数" class="headerlink" title="2. 执行规则和参数"></a>2. 执行规则和参数</h4><h5 id="1-执行某个目录下所有的用例"><a href="#1-执行某个目录下所有的用例" class="headerlink" title="1.执行某个目录下所有的用例"></a>1.执行某个目录下所有的用例</h5><p> <code>pytest</code> 文件名/</p>
<h5 id="2-执行某一个py文件下用例"><a href="#2-执行某一个py文件下用例" class="headerlink" title="2.执行某一个py文件下用例"></a>2.执行某一个py文件下用例</h5><p> <code>pytest</code> 脚本名称.py</p>
<h5 id="3-运行过程中执行打印函数"><a href="#3-运行过程中执行打印函数" class="headerlink" title="3.运行过程中执行打印函数"></a>3.运行过程中执行打印函数</h5><p>pytest -s</p>
<a id="more"></a>

<h5 id="4-收集将要执行的用例，但不会执行"><a href="#4-收集将要执行的用例，但不会执行" class="headerlink" title="4.收集将要执行的用例，但不会执行"></a>4.收集将要执行的用例，但不会执行</h5><p>pytest –collcet-onty</p>
<h5 id="5-k-按关键字匹配（关键字可以是py文件名也可以是函数名，若py文件名和函数均包含-则需要严格指定-xx-py-以运行py文件）"><a href="#5-k-按关键字匹配（关键字可以是py文件名也可以是函数名，若py文件名和函数均包含-则需要严格指定-xx-py-以运行py文件）" class="headerlink" title="5.-k 按关键字匹配（关键字可以是py文件名也可以是函数名，若py文件名和函数均包含 则需要严格指定 xx.py 以运行py文件）"></a>5.-k 按关键字匹配（关键字可以是py文件名也可以是函数名，若py文件名和函数均包含 则需要严格指定 xx.py 以运行py文件）</h5><p> <code>pytest -k</code> “MyClass and not method”</p>
<h5 id="6-按节点运行"><a href="#6-按节点运行" class="headerlink" title="6.按节点运行"></a>6.按节点运行</h5><p> 运行.py模块里面的某个函数</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pytest</span> <span class="selector-tag">test_mod</span><span class="selector-class">.py</span><span class="selector-pseudo">::test_func</span></span><br></pre></td></tr></table></figure>

<p>运行.py模块里面,测试类里面的某个方法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pytest</span> <span class="selector-tag">test_mod</span><span class="selector-class">.py</span><span class="selector-pseudo">::TestClass</span><span class="selector-pseudo">::test_method</span></span><br></pre></td></tr></table></figure>

<h5 id="7-标记表达式"><a href="#7-标记表达式" class="headerlink" title="7.标记表达式"></a>7.标记表达式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pytest -m slow</span><br></pre></td></tr></table></figure>

<p>将运行用<code>@ pytest.mark.slow</code>装饰器修饰的所有测试。</p>
<h5 id="8-从包里面运行"><a href="#8-从包里面运行" class="headerlink" title="8.从包里面运行"></a>8.从包里面运行</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pytest</span> —<span class="selector-tag">pyargs</span> <span class="selector-tag">pkg</span><span class="selector-class">.testing</span></span><br></pre></td></tr></table></figure>

<p>这将导入<code>pkg.testing</code>并使用其文件系统位置来查找和运行测试。</p>
<h5 id="9-pytest-x-遇到错误时停止测试"><a href="#9-pytest-x-遇到错误时停止测试" class="headerlink" title="9.pytest -x( 遇到错误时停止测试)"></a>9.pytest -x( 遇到错误时停止测试)</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pytest</span> <span class="selector-tag">-x</span> <span class="selector-tag">test_class</span><span class="selector-class">.py</span></span><br></pre></td></tr></table></figure>

<h5 id="10-pytest-maxfail-num-当用例错误个数达到指定数量时，停止测试"><a href="#10-pytest-maxfail-num-当用例错误个数达到指定数量时，停止测试" class="headerlink" title="10.pytest -maxfail=num(当用例错误个数达到指定数量时，停止测试)"></a>10.pytest -maxfail=num(当用例错误个数达到指定数量时，停止测试)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pytest —maxfail&#x3D;1</span><br></pre></td></tr></table></figure>

<h5 id="11-参数：-l-或–showlocals"><a href="#11-参数：-l-或–showlocals" class="headerlink" title="11.参数：-l 或–showlocals"></a>11.参数：-l 或–showlocals</h5><p>用例运行失败时，打印相关的局部变量，pytest -l</p>
<h5 id="12-参数：–lf-–last-failed"><a href="#12-参数：–lf-–last-failed" class="headerlink" title="12.参数：–lf / –last-failed"></a>12.参数：–lf / –last-failed</h5><p>只执行上次执行失败的测试</p>
<h5 id="13-参数：–ff-–failed-first"><a href="#13-参数：–ff-–failed-first" class="headerlink" title="13.参数：–ff / –failed-first"></a>13.参数：–ff / –failed-first</h5><p>先执行完上次失败的测试后，再执行上次正常的测试</p>
<h5 id="14-参数：–durations-num-vv（num为0时则倒序显示所有的用例，为具体值则显示耗时最长的对应该数量的用例，-vv-显示持续时间为0秒的用例）"><a href="#14-参数：–durations-num-vv（num为0时则倒序显示所有的用例，为具体值则显示耗时最长的对应该数量的用例，-vv-显示持续时间为0秒的用例）" class="headerlink" title="14.参数：–durations=num -vv（num为0时则倒序显示所有的用例，为具体值则显示耗时最长的对应该数量的用例，-vv 显示持续时间为0秒的用例）"></a>14.参数：–durations=num -vv（num为0时则倒序显示所有的用例，为具体值则显示耗时最长的对应该数量的用例，-vv 显示持续时间为0秒的用例）</h5><p>会按用例执行耗时时长：从长到短 显示结果，用于调优测试代码</p>
<p>比如显示运行耗时最长的3个用例且包含持续时间为0秒的：pytest –durations=3 -vv</p>
<h5 id="15-参数：-r-option"><a href="#15-参数：-r-option" class="headerlink" title="15.参数：-r option"></a>15.参数：-r option</h5><p> 生成简略的指定需求的报告</p>
<h5 id="16-参数-q"><a href="#16-参数-q" class="headerlink" title="16.参数-q"></a>16.参数-q</h5><p>pytest -q 说明：简化控制台的输出，用两个..点代替了pass结果</p>
<h4 id="3-pycharm配置pytest"><a href="#3-pycharm配置pytest" class="headerlink" title="3. pycharm配置pytest"></a>3. pycharm配置pytest</h4><p>以pytest方式运行，需要改该工程设置默认的运行器：file-&gt;Setting-&gt;Tools-&gt;Python Integrated Tools-&gt;项目名称-&gt;Default test runner-&gt;选择pytes</p>
<p><img src="/.io//..%5Cimages%5Cimage-4.png" alt="image-20200622142501975"></p>
]]></content>
      <categories>
        <category>Pytest</category>
      </categories>
      <tags>
        <tag>Pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytest断言(五)</title>
    <url>/2020/06/22/Pytest%E6%96%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="Pytest断言"><a href="#Pytest断言" class="headerlink" title="Pytest断言"></a>Pytest断言</h1><p>断言语句是什么？断言语句是将调试断言插入程序的便捷方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert_stmt :: &#x3D;“assert” expression[“，” expression]</span><br></pre></td></tr></table></figure>

<p>简单的形式， 相当于<code>assert expression</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __debug__:</span><br><span class="line">    if not expression: raise AssertionError</span><br></pre></td></tr></table></figure>

<p>上述代码的意思是，当<code>assert expression</code>为假的时候，就抛出一个异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 栗子</span><br><span class="line">girl &#x3D; False</span><br><span class="line"></span><br><span class="line"># 判断这个人是不是女生</span><br><span class="line">def assert_girl(expression):</span><br><span class="line"></span><br><span class="line">    if not expression:</span><br><span class="line">        raise AssertionError</span><br><span class="line"></span><br><span class="line">assert_girl(girl)</span><br></pre></td></tr></table></figure>

<p>这个栗子会抛出一个<code>AssertionError</code>的异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\Python34\python.exe C:&#x2F;Users&#x2F;lenovo&#x2F;Desktop&#x2F;pytest学习&#x2F;pytest1&#x2F;test_add.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:&#x2F;Users&#x2F;lenovo&#x2F;Desktop&#x2F;pytest学习&#x2F;pytest1&#x2F;test_add.py&quot;, line 26, in &lt;module&gt;</span><br><span class="line">    assert_girl(girl)</span><br><span class="line">  File &quot;C:&#x2F;Users&#x2F;lenovo&#x2F;Desktop&#x2F;pytest学习&#x2F;pytest1&#x2F;test_add.py&quot;, line 24, in assert_girl</span><br><span class="line">    raise AssertionError</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure>

<p>拓展形式，相当于<code>assert expression1,expression2</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __debug__:</span><br><span class="line">    if not expression1: raise AssertionError(expression2)</span><br></pre></td></tr></table></figure>

<p>上诉代码的意思是当<code>assert expression1,expression2</code>为假的时候，就会抛出一个异常。我们最常使用就是这种拓展形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 判断2个数是否相等</span><br><span class="line">def assert_num(expression1, expression2):</span><br><span class="line"></span><br><span class="line">    expression &#x3D; expression1 &#x3D;&#x3D; expression2</span><br><span class="line">    if not expression:</span><br><span class="line">        raise AssertionError</span><br><span class="line"></span><br><span class="line">assert_num(1, 2)</span><br></pre></td></tr></table></figure>

<p>同样这个栗子也会抛出一个异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:&#x2F;Users&#x2F;lenovo&#x2F;Desktop&#x2F;pytest学习&#x2F;pytest1&#x2F;test_add.py&quot;, line 24, in &lt;module&gt;</span><br><span class="line">    assert_num(1, 2)</span><br><span class="line">  File &quot;C:&#x2F;Users&#x2F;lenovo&#x2F;Desktop&#x2F;pytest学习&#x2F;pytest1&#x2F;test_add.py&quot;, line 22, in assert_num</span><br><span class="line">    raise AssertionError</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure>

<h3 id="断言的使用"><a href="#断言的使用" class="headerlink" title="断言的使用"></a>断言的使用</h3><ul>
<li>断言，一般是用来帮忙我们，确定一个结果是不是正确。如果不是，就需要它抛出一个异常来告诉我们，这个结果是错误的。</li>
<li>在pytest中，不需要是用<code>self.assert.*</code>的形式来进行断言。只需要<code>assert</code>内置函数就可以直接进行断言。降低了我们对断言学习成本</li>
<li><code>assert</code>后面可以接表达式，如<code>assert 1==2</code>，其实就是我们上面所说的拓展模式的断言。</li>
</ul>
<p>现在我们对一个登录接口进行断言，先创建一个<code>test_login</code>的py文件。定义一个<code>login</code>的接口，和<code>test_login</code>的用例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 登录接口</span><br><span class="line">def login(username, password):</span><br><span class="line"></span><br><span class="line">    # 在这里，我就不做数据库查询了,只是举一个简单的例子,只要用户名和密码传值，就算登录成功</span><br><span class="line">    if username or password:</span><br><span class="line">        return &#123;&quot;message&quot;:&quot;登录成功&quot;, &quot;code&quot;: 0&#125;</span><br><span class="line">    else:</span><br><span class="line">        return &#123;&quot;message&quot;:&quot;账号或密码错误&quot;, &quot;code&quot;: 400&#125;</span><br><span class="line"></span><br><span class="line"># 接口测试用例</span><br><span class="line">def test_login():</span><br><span class="line"></span><br><span class="line">    res &#x3D; login(&quot;admin&quot;, &quot;123456&quot;)</span><br><span class="line">    assert res[&#39;code&#39;] &#x3D;&#x3D; 1</span><br></pre></td></tr></table></figure>

<p>在cmd运行测试用例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pytest</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\lenovo\Desktop\pytest学习&gt;pytest                                                                                                                                                                                            </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; test session starts &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">platform win32 -- Python 3.4.4, pytest-3.8.0, py-1.6.0, pluggy-0.7.1</span><br><span class="line">rootdir: C:\Users\lenovo\Desktop\pytest学习, inifile:                                                                                                                                                                                </span><br><span class="line">plugins: celery-4.2.1, allure-adaptor-1.7.10, html-1.19.0, metadata-1.7.0</span><br><span class="line">collected 1 item                                                               </span><br><span class="line"></span><br><span class="line">pytest1\test_add.py F                                                    [100%]</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; FAILURES &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">_________________________________ test_login __________________________________</span><br><span class="line"></span><br><span class="line">    def test_login():</span><br><span class="line">    </span><br><span class="line">        res &#x3D; login(&quot;admin&quot;, &quot;123456&quot;)</span><br><span class="line">&gt;       assert res[&#39;code&#39;] &#x3D;&#x3D; 1</span><br><span class="line">E       assert 0 &#x3D;&#x3D; 1</span><br><span class="line"></span><br><span class="line">pytest1\test_add.py:30: AssertionError</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1 failed in 0.20 seconds &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Pytest</category>
      </categories>
      <tags>
        <tag>Pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm2020版本激活</title>
    <url>/2020/05/29/Pycharm2020%E7%89%88%E6%9C%AC%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<h1 id="Pycharm永久激活"><a href="#Pycharm永久激活" class="headerlink" title="Pycharm永久激活"></a>Pycharm永久激活</h1><p>1、官网下载专业版 <a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm/</a></p>
<p>2、下载与之匹配的jar包 百度网盘链接：<a href="https://pan.baidu.com/s/1EOjpH4kkv_5dsyWObROMZg" target="_blank" rel="noopener">https://pan.baidu.com/s/1EOjpH4kkv_5dsyWObROMZg</a></p>
<p>​       提取码：us7z</p>
<p>3、将<code>jetbrains-agent.jar</code>文件复制到pycharm的安装路径的lib文件夹中。</p>
<a id="more"></a>

<p>4、打开pycharm，选择免费试用。若已经过了试用期，可以点击第2步中的第2个文件夹 “reset_eval” 中的 “reset_jetbrains_eval_windows.vbs” 来重置使用状态）。</p>
<p>5、在pycharm创建一个项目，点击顶部菜单栏的 “Help”，点击 “Edit Custom VM Options”</p>
<p>6、找到刚刚 pycharm2020.1 的安装路径下的<code>lib</code>文件夹 下的 <code>jetbrains-agent.jar</code>，复制好安装路径</p>
<p>7、然后回到 pycharm界面，复制进去，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-javaagent:D:\software\PyCharm 2020.1.1\lib\jetbrains-agent.jar</span><br></pre></td></tr></table></figure>

<p><img src="/.io//..%5Cimages%5C2.png" alt="image-20200608152530746"></p>
<p>8、然后把这个之前解压的 <code>jetbrains-agent.jar</code> 直接拖进 pycharm，点击restart重启pycharm</p>
<p>9、打开并复制第2步 “激活码（备用）.txt”中的激活码，点击pycharm菜单栏中Help中的Register</p>
<p>10、点击 “Activation code”，把复制好的激活码粘贴进去，点击 “Activate” 激活</p>
]]></content>
      <categories>
        <category>Pycharm</category>
      </categories>
      <tags>
        <tag>Pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytest的简单运行(二)</title>
    <url>/2020/06/22/Pytest%E7%9A%84%E7%AE%80%E5%8D%95%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="Pytest的简单运行"><a href="#Pytest的简单运行" class="headerlink" title="Pytest的简单运行"></a>Pytest的简单运行</h1><p>上一节，我们已经安装好allure和pytest的方法。也简单的举了一个例子，但是我们还不太明白pytest和allure他的实际意义。所以，从这节开始，我们先从pytest开始学习。</p>
<h3 id="Pytest的简单运行-1"><a href="#Pytest的简单运行-1" class="headerlink" title="Pytest的简单运行"></a>Pytest的简单运行</h3><p>pytest框架可以轻松编写小型测试，然后进行扩展以支持应用程序和库的复杂功能测试。 </p>
<p>创建一个名为<code>test_add</code>的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add(x, y):</span><br><span class="line"></span><br><span class="line">    return x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_add():</span><br><span class="line"></span><br><span class="line">    assert add(1, 2) &#x3D;&#x3D; 3</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>以上代码做2件事</p>
<ul>
<li>定义了一个全局函数<code>add</code>，返回x，y两个值的和。</li>
<li>定义了一个函数<code>test_add</code>，包含了一个断言，用来验证add函数的正确性</li>
</ul>
<p>在<code>pycharm</code>中的<code>cmd</code>中运行测试用例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pytest</span><br></pre></td></tr></table></figure>

<p>会得到以下的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\lenovo\Desktop\pytest学习&gt;pytest                                                                                                                                                                                            </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; test session starts &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">platform win32 -- Python 3.4.4, pytest-3.8.0, py-1.6.0, pluggy-0.7.1</span><br><span class="line">rootdir: C:\Users\lenovo\Desktop\pytest学习, inifile:                                                                                                                                                                                </span><br><span class="line">plugins: celery-4.2.1, allure-adaptor-1.7.10, html-1.19.0, metadata-1.7.0</span><br><span class="line">collected 1 item                                                               </span><br><span class="line"></span><br><span class="line">pytest1\test_add.py .                                                    [100%]</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1 passed in 0.27 seconds &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>上述用例，<code>add(1,2)=3</code>所以运行通过，同样在pytest中可以使用assert来进行断言</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>与unittest相比，使用pytest框架不需要继承pytest的类</li>
<li>只需要一个简单cmd命令就可以执行测试用例</li>
</ul>
]]></content>
      <categories>
        <category>Pytest</category>
      </categories>
      <tags>
        <tag>Pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytest文件命名规则(三)</title>
    <url>/2020/06/22/Pytest%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Pytest运行多个文件"><a href="#Pytest运行多个文件" class="headerlink" title="Pytest运行多个文件"></a>Pytest运行多个文件</h1><h3 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h3><p>在执行测试用例之前，我们需要先了解一下<code>pytest</code>中的文件命名规则。</p>
<ul>
<li><p>pytest会从当前目录向下递归寻找，以<code>test_*.py</code>开头或以<code>*_test.py</code>结尾的文件。把他们当做测试文件。</p>
</li>
<li><p>在这些文件中，pytest</p>
<p>会提取当中以下的函数或者方法。</p>
<ul>
<li>以<code>Test</code>开头，不包含<code>__init__</code>方法的类，其中的以<code>test_</code>开头的函数或方法。</li>
<li>文件中的以<code>test_</code>开头的函数。</li>
</ul>
</li>
<li><p><code>pytest</code>还支持<code>unittest.TestCase</code>的方式来加载测试用例。</p>
<a id="more"></a>

</li>
</ul>
<h3 id="在一个类中运行多个用例"><a href="#在一个类中运行多个用例" class="headerlink" title="在一个类中运行多个用例"></a>在一个类中运行多个用例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># content of test_class.py</span><br><span class="line">class TestClass(object):</span><br><span class="line">    def test_one(self):</span><br><span class="line">        x &#x3D; &quot;this&quot;</span><br><span class="line">        assert &#39;h&#39; in x</span><br><span class="line"></span><br><span class="line">    def test_two(self):</span><br><span class="line">        x &#x3D; &quot;hello&quot;</span><br><span class="line">        assert hasattr(x, &#39;check&#39;)</span><br></pre></td></tr></table></figure>

<p><code>pytest</code>会发现遵循命名规则的所有测试，因此它找到两个<code>test_</code>前缀函数。没有必要继承任何东西。我们可以通过传递文件名来运行模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pytest -q test_class.py</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pytest -q test_class.py</span><br><span class="line">.F                                                                   [100%]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; FAILURES &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">____________________________ TestClass.test_two ____________________________</span><br><span class="line"></span><br><span class="line">self &#x3D; &lt;test_class.TestClass object at 0xdeadbeef&gt;</span><br><span class="line"></span><br><span class="line">    def test_two(self):</span><br><span class="line">        x &#x3D; &quot;hello&quot;</span><br><span class="line">&gt;       assert hasattr(x, &#39;check&#39;)</span><br><span class="line">E       AssertionError: assert False</span><br><span class="line">E        +  where False &#x3D; hasattr(&#39;hello&#39;, &#39;check&#39;)</span><br><span class="line"></span><br><span class="line">test_class.py:8: AssertionError</span><br><span class="line">1 failed, 1 passed in 0.12 seconds</span><br></pre></td></tr></table></figure>

<p>同时<code>pytest</code>对<code>unittest</code>的也是支持的。首先创建一个<code>test_unittest_case.py</code>，示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># test_uniitest_case.py</span><br><span class="line">import unittest</span><br><span class="line">class Test(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def test_1(self):</span><br><span class="line">        assert 1 &#x3D;&#x3D; 3</span><br><span class="line"></span><br><span class="line">    def test_2(self):</span><br><span class="line">        assert 2 &#x3D;&#x3D; abs(-2)</span><br></pre></td></tr></table></figure>

<p>然后命令行进入到<code>test_unittest_case.py</code>的所在目录。执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pytest -q test_unittest_case.py</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\lenovo\Desktop\pytest学习\pytest1&gt;pytest -q test_unittest_case.py                                                                                                                                                                </span><br><span class="line">F.                                                                       [100%]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; FAILURES &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">_________________________________ Test.test_1 _________________________________</span><br><span class="line"></span><br><span class="line">self &#x3D; &lt;test_unittest_case.Test testMethod&#x3D;test_1&gt;</span><br><span class="line"></span><br><span class="line">    def test_1(self):</span><br><span class="line">&gt;       assert 1 &#x3D;&#x3D; 3</span><br><span class="line">E       AssertionError: assert 1 &#x3D;&#x3D; 3</span><br><span class="line"></span><br><span class="line">test_register.py:26: AssertionError</span><br><span class="line">1 failed, 1 passed in 0.10 seconds</span><br></pre></td></tr></table></figure>

<h3 id="运行多个文件"><a href="#运行多个文件" class="headerlink" title="运行多个文件"></a>运行多个文件</h3><p>在实际测试过程中，我们会有多个测试文件，所以需要对多文件进行批量测试。</p>
<p>如登录和注册接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test_login.py # 登录业务测试</span><br><span class="line">test_register.py # 注册业务测试</span><br></pre></td></tr></table></figure>

<p>用例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># test_login.py</span><br><span class="line">def login(username, password):</span><br><span class="line"></span><br><span class="line">    # 在这里，我就不做数据库查询了,只是举一个简单的例子,只要用户名和密码传值，就算登录成功</span><br><span class="line">    if username or password:</span><br><span class="line">        return &#123;&quot;message&quot;:&quot;登录成功&quot;, &quot;code&quot;: 0&#125;</span><br><span class="line">    else:</span><br><span class="line">        return &#123;&quot;message&quot;:&quot;账号或密码错误&quot;, &quot;code&quot;: 400&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_login():</span><br><span class="line"></span><br><span class="line">    res &#x3D; login(&quot;admin&quot;, &quot;123456&quot;)</span><br><span class="line">    assert res[&#39;code&#39;] &#x3D;&#x3D; 1</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"># test_register.py</span><br><span class="line">def register(username, password):</span><br><span class="line"></span><br><span class="line">    if username or password:</span><br><span class="line">        return &#123;&quot;message&quot;: &quot;注册成功&quot;, &quot;code&quot;: 0&#125;</span><br><span class="line">    else:</span><br><span class="line">        return &#123;&quot;message&quot;: &quot;账号或密码错误&quot;, &quot;code&quot;: 400&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_register():</span><br><span class="line"></span><br><span class="line">    res &#x3D; register(&quot;root&quot;, &quot;123456&quot;)</span><br><span class="line">    assert res.get(&quot;code&quot;) &#x3D;&#x3D; 0</span><br></pre></td></tr></table></figure>

<p>在<code>pytest</code>运行多个文件进行批量测试，也是非常简单的，只需要在当前的根目录下pycharm中的cmd执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pytest</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\lenovo\Desktop\pytest学习&gt;pytest                                                                                                                                                                                            </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; test session starts &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">platform win32 -- Python 3.4.4, pytest-3.8.0, py-1.6.0, pluggy-0.7.1</span><br><span class="line">rootdir: C:\Users\lenovo\Desktop\pytest学习, inifile:                                                                                                                                                                                </span><br><span class="line">plugins: celery-4.2.1, allure-adaptor-1.7.10, html-1.19.0, metadata-1.7.0</span><br><span class="line">collected 2 items                                                              </span><br><span class="line"></span><br><span class="line">pytest1\test_login.py F                                                  [ 50%]</span><br><span class="line">pytest1\test_register.py .                                               [100%]</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; FAILURES &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">_________________________________ test_login __________________________________</span><br><span class="line"></span><br><span class="line">    def test_login():</span><br><span class="line">    </span><br><span class="line">        res &#x3D; login(&quot;admin&quot;, &quot;123456&quot;)</span><br><span class="line">&gt;       assert res[&#39;code&#39;] &#x3D;&#x3D; 1</span><br><span class="line">E       assert 0 &#x3D;&#x3D; 1</span><br><span class="line"></span><br><span class="line">pytest1\test_login.py:30: AssertionError</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1 failed, 1 passed in 0.22 seconds &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Pytest</category>
      </categories>
      <tags>
        <tag>Pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium3工作原理及环境搭建</title>
    <url>/2020/05/26/selenium/</url>
    <content><![CDATA[<p>一、selenium简介</p>
<p>selenium是一个应用于web应用程序的自动化测试工具。支持的浏览器包括IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera等。</p>
<p>selenium2主要是集成了webdriver，webdriver是按照server-client的经典模式设计的。server：即remote server，可以是任意浏览器，它的职责是等待client发送请求并作出响应。client端简单说来就是我们的测试代码：比如打开浏览器，转跳到特定的url等操作是以http请求的方式发送给被server端（也就是被测浏览器）server接受请求，并执行相应操作，并在response中返回执行状态、返回值等信息；</p>
<p>主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。</p>
<p>​              测试系统功能——创建回归测试检验软件功能和用户需求。</p>
<a id="more"></a>

<p>二、webdriver原理</p>
<p>我们使用selenium实现自动化测试，需要准备三个基础条件</p>
<p>1、测试脚本，可以是python or Java编写的脚本程序(也可以叫做client端)</p>
<p>2、浏览器驱动，不同的浏览器使用不同的webdriver驱动程序且需要对应浏览器的版本</p>
<p>3、浏览器</p>
<p>实现：启动浏览器后，selenium-webdriver会将目标浏览器绑定到特定的端口，启动后的浏览器则作为webdriver的remote server。</p>
<p>客户端(也就是测试脚本)，发送HTTP请求给sever端（通信协议：The WebDriver Wire Protocol，在HTTP request的body中，会以WebDriver Wire协议规定的JSON格式的字符串来告诉Selenium我们希望浏览器接下来做什么事情）。</p>
<p>Sever端需要依赖原生的浏览器组件，转化Web Service的命令为浏览器的调用来完成操作。</p>
<p>三、环境搭建</p>
<p>我以谷歌浏览器为例子。若是使用其他浏览器，则下载相应的浏览器及驱动即可。</p>
<p>1、首先安装python。推荐安装python3，官网自行下载安装即可。</p>
<p>2、安装python后，pip install selenium,安装selenium包。</p>
<p>3、谷歌浏览器以及chrome驱动。驱动下载地址：<a href="http://npm.taobao.org/mirrors/chromedriver/，选择对应的谷歌版本的驱动下载即可。驱动可以直接丢在python的安装目录下或者单独配置环境变量。" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/，选择对应的谷歌版本的驱动下载即可。驱动可以直接丢在python的安装目录下或者单独配置环境变量。</a></p>
<p>在此步骤中可以关闭谷歌浏览器的自动更新，不然更新之后你下载的驱动可能用不了了。</p>
<p>四、测试</p>
<p>在pycharm中建立python文件</p>
<p>输入如下代码 如果能正常打开浏览器说明环境已经大功告成了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line">driver = webdriver.Chrome()</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Selenium</category>
      </categories>
      <tags>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytest+allure环境搭建(一)</title>
    <url>/2020/06/22/pytest%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Pytest加allure环境搭建"><a href="#Pytest加allure环境搭建" class="headerlink" title="Pytest加allure环境搭建"></a>Pytest加allure环境搭建</h1><h3 id="pytest的安装"><a href="#pytest的安装" class="headerlink" title="pytest的安装:"></a>pytest的安装:</h3><p>windows下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure>

<p>linux下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure>

<h3 id="安装pytest-allure-adaptor插件"><a href="#安装pytest-allure-adaptor插件" class="headerlink" title="安装pytest-allure-adaptor插件"></a>安装pytest-allure-adaptor插件</h3><p>windows下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pytest-allure-adaptor</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="allure的安装"><a href="#allure的安装" class="headerlink" title="allure的安装:"></a>allure的安装:</h3><p>windows下:</p>
<p>前情提示： allure是基于<code>Java</code>的一个程序，需要Java1.8的环境，没有安装需要去安装一下。</p>
<p><a href="https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/allure-2.7.0.zip" target="_blank" rel="noopener">Windows下不能直接安装，点击此链接下载压缩包</a></p>
<p>下载之后，将压缩包解压到一个磁盘中，我这里用的是<code>F</code>盘</p>
<p><img src="http://pythonbooks.oss-cn-beijing.aliyuncs.com/18-9-14/78005817.jpg?ynotemdtimestamp=1592795250655" alt="img"></p>
<p>配置allure的环境变量</p>
<p><img src="http://pythonbooks.oss-cn-beijing.aliyuncs.com/18-9-14/10734144.jpg?ynotemdtimestamp=1592795250655" alt="img"></p>
<p><img src="http://pythonbooks.oss-cn-beijing.aliyuncs.com/18-9-14/64126815.jpg?ynotemdtimestamp=1592795250655" alt="img"></p>
<p>点击确定，保存。这样就可以通过CMD使用allure命令</p>
<p>pycharm新建一个test_demo.py文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import allure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@allure.MASTER_HELPER.feature(&quot;测试Dome&quot;)</span><br><span class="line">class TestDome(object):</span><br><span class="line"></span><br><span class="line">    @allure.MASTER_HELPER.step(&quot;定义被测函数&quot;)</span><br><span class="line">    def func(self, x):</span><br><span class="line">        return x+1</span><br><span class="line"></span><br><span class="line">    @allure.MASTER_HELPER.story(&quot;被测场景&quot;)</span><br><span class="line">    @allure.MASTER_HELPER.severity(&quot;blocker&quot;)</span><br><span class="line">    @allure.MASTER_HELPER.step(&quot;断言结果&quot;)</span><br><span class="line">    def test_func(self):</span><br><span class="line">        # with allure.MASTER_HELPER.step(&quot;断言结果&quot;):</span><br><span class="line">        allure.MASTER_HELPER.attach(&quot;预期结果&quot;, &quot;&#123;&#125;&quot;.format(self.func(3)))</span><br><span class="line">        allure.MASTER_HELPER.attach(&quot;实际结果&quot;, &quot;&#123;&#125;&quot;.format(5))</span><br><span class="line">        assert self.func(3) &#x3D;&#x3D; 5</span><br></pre></td></tr></table></figure>

<p>在pycharm中打开terminal</p>
<p>输入命令 <code>pytest -s --alluredir=report</code>，会遇到以下这个错误：</p>
<p><img src="http://pythonbooks.oss-cn-beijing.aliyuncs.com/18-9-14/27972244.jpg?ynotemdtimestamp=1592795250655" alt="img"></p>
<p>进入allure下面的utils文件，修改以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># utils文件，可以通过from allure import utlis进入</span><br><span class="line"></span><br><span class="line">for suitable_name in suitable_names:</span><br><span class="line">            # markers.append(item.get_marker(suitable_name))</span><br><span class="line">            markers.append(item.get_closest_marker(suitable_name))</span><br></pre></td></tr></table></figure>

<p><img src="http://pythonbooks.oss-cn-beijing.aliyuncs.com/18-9-14/98217046.jpg?ynotemdtimestamp=1592795250655" alt="img"></p>
<p>修改之后，再次运行<code>pytest -s --alluredir=report</code>命令：</p>
<p><img src="http://pythonbooks.oss-cn-beijing.aliyuncs.com/18-9-14/56651827.jpg?ynotemdtimestamp=1592795250655" alt="img"></p>
<p>运行后，无上述错误，同时会生成一个report文件。其中会有一个xml格式的报告:</p>
<p><img src="http://pythonbooks.oss-cn-beijing.aliyuncs.com/18-9-14/3923690.jpg?ynotemdtimestamp=1592795250655" alt="img"></p>
<p><img src="http://pythonbooks.oss-cn-beijing.aliyuncs.com/18-9-14/82638527.jpg?ynotemdtimestamp=1592795250655" alt="img"></p>
<p>当然xml格式的报告不够直观，我们需要通过allure将它转成HTML格式的报告。通过cmd命令cd到report的根目录下，执行<code>allure generate --clean report</code></p>
<p>回到根目录下，会生成一个allure-report的文件夹，在pycharm中打开文件夹，点击index.html运行</p>
<p><img src="/.io//..%5Cimages%5Cimage-3.png" alt="image-20200622111338731"></p>
<p>ok，到此为止。可以看到我们的精美的测试报告了</p>
<p><img src="http://pythonbooks.oss-cn-beijing.aliyuncs.com/18-9-14/26422942.jpg?ynotemdtimestamp=1592795250655" alt="img"></p>
<p><img src="http://pythonbooks.oss-cn-beijing.aliyuncs.com/18-9-14/54109731.jpg?ynotemdtimestamp=1592795250655" alt="img"></p>
]]></content>
      <categories>
        <category>Pytest</category>
      </categories>
      <tags>
        <tag>Pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytest前后置方法(六)</title>
    <url>/2020/06/22/pytest%E5%89%8D%E5%90%8E%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="pytest前后置方法"><a href="#pytest前后置方法" class="headerlink" title="pytest前后置方法"></a>pytest前后置方法</h1><h3 id="一、级别"><a href="#一、级别" class="headerlink" title="一、级别"></a>一、级别</h3><p><strong>模块级（setup_module/teardown_module）开始于模块始末，全局的</strong></p>
<p><strong>函数级（setup_function/teardown_function）只对函数用例生效（不在类中）</strong></p>
<p><strong>类级（setup_class/teardown_class）只在类中前后运行一次(在类中)</strong></p>
<p><strong>方法级（setup_method/teardown_method）开始于方法始末（在类中）</strong></p>
<p><strong>类里面的（setup/teardown）运行在调用方法的前后</strong></p>
<a id="more"></a>

<h5 id="1-1setup-module-teardown-module（所有用例开始和结束时调用一次）"><a href="#1-1setup-module-teardown-module（所有用例开始和结束时调用一次）" class="headerlink" title="1.1setup_module/teardown_module（所有用例开始和结束时调用一次）"></a>1.1setup_module/teardown_module（所有用例开始和结束时调用一次）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_module</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"setup_module：整个.py模块只执行一次"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_module</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"teardown_module：整个.py模块只执行一次"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"正在执行----test_one"</span>)</span><br><span class="line">    x = <span class="string">"this"</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">'h'</span> <span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"正在执行----test_two"</span>)</span><br><span class="line">    x = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">assert</span> hasattr(x, <span class="string">'check'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_three</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"正在执行----test_three"</span>)</span><br><span class="line">    a = <span class="string">"hello"</span></span><br><span class="line">    b = <span class="string">"hello world"</span></span><br><span class="line">    <span class="keyword">assert</span> a <span class="keyword">in</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pytest.main([<span class="string">"-s"</span>, <span class="string">"test_module.py"</span>])</span><br></pre></td></tr></table></figure>

<p>打印如下</p>
<p><img src="/.io//..%5Cimages%5Cimage-5.png" alt="image-20200622153045480"></p>
<h5 id="1-2setup-function-teardown-function（每个用例开始和结束时调用一次）"><a href="#1-2setup-function-teardown-function（每个用例开始和结束时调用一次）" class="headerlink" title="1.2setup_function/teardown_function（每个用例开始和结束时调用一次）"></a>1.2setup_function/teardown_function（每个用例开始和结束时调用一次）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"setup_function：每个用例开始前都会执行"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"teardown_function：每个用例结束前都会执行"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"正在执行----test_one"</span>)</span><br><span class="line">    x = <span class="string">"this"</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">'h'</span> <span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"正在执行----test_two"</span>)</span><br><span class="line">    x = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">assert</span> hasattr(x, <span class="string">'check'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_three</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"正在执行----test_three"</span>)</span><br><span class="line">    a = <span class="string">"hello"</span></span><br><span class="line">    b = <span class="string">"hello world"</span></span><br><span class="line">    <span class="keyword">assert</span> a <span class="keyword">in</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pytest.main([<span class="string">"-s"</span>, <span class="string">"test_module.py"</span>])</span><br></pre></td></tr></table></figure>

<p>打印如下：</p>
<p><img src="/.io//..%5Cimages%5Cimage-6.png" alt="image-20200622153408515"></p>
<h5 id="1-3类级和方法级"><a href="#1-3类级和方法级" class="headerlink" title="1.3类级和方法级"></a>1.3类级和方法级</h5><p>setup/teardown和unittest里面的setup/teardown是一样的功能，setup_class和teardown_class等价于unittest里面的setupClass和teardownClass</p>
<p>这里setup_method和teardown_method的功能和setup/teardown功能是一样的，一般二者用其中一个即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="comment"># 类和方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCase</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"setup: 每个用例开始前执行"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teardown</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"teardown: 每个用例结束后执行"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"setup_class：所有用例执行之前"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teardown_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"teardown_class：所有用例结束后执行"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"setup_method:  每个用例开始前执行方法"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teardown_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"teardown_method:  每个用例结束后执行方法"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"正在执行----test_one"</span>)</span><br><span class="line">        x = <span class="string">"this"</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">'h'</span> <span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"正在执行----test_two"</span>)</span><br><span class="line">        a = <span class="string">"hello"</span></span><br><span class="line">        b = <span class="string">"hello world"</span></span><br><span class="line">        <span class="keyword">assert</span> a <span class="keyword">in</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pytest.main([<span class="string">"-s"</span>, <span class="string">"test_module.py"</span>])</span><br></pre></td></tr></table></figure>

<p>打印如下</p>
<p><img src="/.io//..%5Cimages%5Cimage-7.png" alt="image-20200622154047605"></p>
<h5 id="1-4混合使用"><a href="#1-4混合使用" class="headerlink" title="1.4混合使用"></a>1.4混合使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="comment"># 类和方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_module</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"setup_module：整个.py模块只执行一次"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_module</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"teardown_module：整个.py模块只执行一次"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"setup_function：每个用例开始前都会执行"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"teardown_function：每个用例结束前都会执行"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"正在执行----test_one"</span>)</span><br><span class="line">    x = <span class="string">"this"</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">'h'</span> <span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"正在执行----test_two"</span>)</span><br><span class="line">    x = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">assert</span> hasattr(x, <span class="string">'check'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCase</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"setup_class：所有用例执行之前"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teardown_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"teardown_class：所有用例执行之前"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_three</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"正在执行----test_three"</span>)</span><br><span class="line">        x = <span class="string">"this"</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">'h'</span> <span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_four</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"正在执行----test_four"</span>)</span><br><span class="line">        x = <span class="string">"hello"</span></span><br><span class="line">        <span class="keyword">assert</span> hasattr(x, <span class="string">'check'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pytest.main([<span class="string">"-s"</span>, <span class="string">"test_module.py"</span>])</span><br></pre></td></tr></table></figure>

<p>打印如下</p>
<p>从运行结果看出，setup_module/teardown_module的优先级是最大的，然后函数里面用到的setup_function/teardown_function与类里面的setup_class/teardown_class互不干涉</p>
<p><img src="/.io//..%5Cimages%5Cimage-8.png" alt="image-20200622154613618"></p>
]]></content>
      <categories>
        <category>Pytest</category>
      </categories>
      <tags>
        <tag>Pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium常用Api</title>
    <url>/2020/05/28/selenium%E5%B8%B8%E7%94%A8Api/</url>
    <content><![CDATA[<p>selenium常用Api</p>
<p>一、获取各个属性值</p>
<p>1、driver.current_url</p>
]]></content>
  </entry>
  <entry>
    <title>Selenium3元素定位</title>
    <url>/2020/05/26/%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>1、id定位：find_element_by_id()。通过标签的id属性来定位</p>
<p>2、name定位:find_element_by_name()。通过标签的name属性来定位</p>
<p>3、class定位:find_element_by_class_name()。通过标签的class属性来定位</p>
<p>4、tag定位:find_element_by_tag_name()。通过标签的名称来定位，比如input是输入、table是表格等等。一个tag往往用来定义一类功能。</p>
<p>5、link定位以及partial_link定位:find_element_by_link_text() 、find_element_by_partial_link_text()。通过超链接的全部或部分文本内容进行定位</p>
<p>6、xpath定位:find_element_by_xpath()。</p>
<p>7、css定位:find_element_by_css_selector()</p>
<a id="more"></a>

<p>前五种适用于：在当前页面中，每个元素都有一个唯一的id或name或class或超链接文本的属性，那么我们就可以通过这个唯一的属性值来定位他们。</p>
<p>大部分人在使用selenium定位元素时，用的是xpath定位，因为xpath基本能解决定位的需求。</p>
<p>css定位往往被忽略掉了，其实css定位也有它的价值，css定位更快，语法更简洁。<br> 一：css:属性定位</p>
<p>1、css可以通过元素的id、class、标签这三个常规属性直接定位，如下：<br> ①. css用#号表示id属性，如：<br> id=“kw” 可以写成：#kw<br> ②. css用.表示class属性，如：<br> class=”s_ipt”可以写成：.s_ipt<br> ③. css直接用标签名称，无任何标识符，如：input</p>
<p>二：css：其他属性<br> 1、css除了上述以外，也可以通过其他属性定位，如下：<br> ①. css通过name属性定位：<br> driver.find_element(By.CSS_SELECTOR,”[name=’wd’]”)<br> ②. css通过autocomplete属性定位：<br> driver.find_element(By. CSS_SELECTOR,”[autocomplete=’off’]”)<br> ③.css通过type属性定位:<br> driver.find_element(By.CSS_SELECTOR,”[type=’text’]”)</p>
<p>三：css：标签<br> 1、css页可以通过标签与属性的组合来定位元素，如下：<br> ①. css通过标签与class属性的组合定位driver.find_element(By.CSS_SELECTOR,”input.s_ipt”)<br> ②. css通过标签与id属性的组合定位driver.find_element(By.CSS_SELECTOR,”input#kw”)<br> ③. css通过标签与其他属性组合定位driver.find_element(By.CSS_SELECTOR,”input[id=’kw’]”)</p>
<p>四：css:层级关系<br> 1、如：//form[@id=‘form’]/span/input和//form[@class=‘fm’]/span/input<br> ①. css通过层级关系定位driver.find_element(By.CSS_SELECTOR,”form#form&gt;span&gt;input”)<br> ②. css通过层级关系定位driver.find_element(By.CSS_SELECTOR,”form.fm&gt;span&gt;input”)</p>
<p>五：css：索引<br> 1、css也可以通过索引option：nth-child(1)来定位子元素，如下：<br> ①. 选择第一个子元素driver.find_element(By.CSS_SELECTOR,”select#nr&gt;option:nth-child(1)”)<br> ②. 选择第二个子元素driver.find_element(By.CSS_SELECTOR,”select#nr&gt;option:nth-child(2)”)<br> ③. 选择第三个子元素driver.find_element(By.CSS_SELECTOR,”select#nr&gt;option:nth-child(3)”)</p>
<p>六：css：逻辑运算<br> 1、css同时匹配两个属性，不需要and关键字driver.find_element(By.CSS_SELECTOR,”input[id=’kw’][name=’wd’]”)</p>
<p>七：css：模糊匹配driver.find_element(By.CSS_SELECTOR,”input:contains(‘kw’)”)</p>
<p>一、xpath：属性定位<br> 1、xpath也可以通过元素的id、name、class这些属性定位，如下：<br> ①. 用xpath通过id属性定位<br> driver.find_element(By.XPATH,”//<em>[@id=’kw’]”)<br> ②. 用xpath通过name属性定位<br> driver.find_element(By.XPATH,”//</em>[@name=’wd’]”)<br> ③. 用xpath通过class属性定位<br> driver.find_element(By.XPATH,”//*[@class=’s_ipt’]”)</p>
<p>二、xpath：其他属性<br> 1、没有上述属性，可以通过其他属性定位，如下：<br> driver.find_element(By.XPATH,”//*[@autocomplete=’off’]”)</p>
<p>三、xpath：标签<br> 1、如果同一个属性，同名的比较多，可以通过标签筛选下<br> 2、如果不想制定标签名称，可以用号表示任意标签<br> 3、如果想制定具体某个标签，就可以直接写标签名称<br> ①. 用xpath通过其他属性定位driver.find_element(By.XPATH,”//input[@autocomplete=’off’]”)<br> ②. 用xpath通过id属性定位driver.find_element(By.XPATH,”//input[@id=’kw’]”)<br> ③. 用xpath通过name属性定位driver.find_element(By.XPATH,”//name[@id=’wd’]”)</p>
<p>四、xpath：层级<br> 1、如果一个元素，他的属性不明显，无法直接定位，可以先找到他的父元素<br> 2、找到父元素，再找下一级就能定位<br> ①. 通过定位父元素来定位input输入框driver.find_element(By.XPATH,”//span[@id=’s_kw_wrap’]/input”)<br> ②. 通过定位爷元素来定位input输入框driver.find_element(By.XPATH,”//form[@id=’form’]/span/input”)</p>
<p>五、xpath：索引<br> 1、如果一个元素和他同级的标签一样，无法通过层级定位<br> 2、可以通过排序定位<br> ①. 用xpath定位第一位driver.find_element(By.XPATH,”//select[@id=’nr’]/option[1]”)<br> ②. 用xpath定位第二位driver.find_element(By.XPATH,”//select[@id=’nr’]/option[2]”)<br> ③. 用xpath定位第三位driver.find_element(By.XPATH,”//select[@id=’nr’]/option[3]”)</p>
<p>六、xpath：逻辑运算<br> 1、xpath还有一个比较强的功能，是可以多个属性逻辑运算的，可以支持and、or、not<br> 2、一般用的比较多的是and运算，同时满足两个属性driver.find_element(By.XPATH,”//select[@id=’nr’ and @autocomplete=’off’]”)<br> 七、xpath：模糊匹配<br> 1、xpath强大的模糊匹配<br> 2、掌握了模糊匹配功能，基本上没有定位不到的<br> 3、by_partial_link，模糊匹配定位<br> driver.find_element(By.XPATH,”//*[contains(text(),’hao123’)]”)</p>
]]></content>
      <categories>
        <category>Selenium</category>
      </categories>
      <tags>
        <tag>Selenium</tag>
      </tags>
  </entry>
</search>
